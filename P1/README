	I did option 1 (with line counting); the output is token type, "the token given", then line number.

############################################################

Implement scanner for the provided lexical definitions.

The scanner is embedded and thus it will return one token every time it is called. Since the parser is not available yet, we will use a tester program to call the scanner.

The scanner could be implemented as
Plain string reader - read strings separated by spaces - (70 points) assuming
all tokens must be separated by spaces
lines may not be counted (75 if counted)
comments may be without spaces
Module generated by lex (+5 points)
FSA table + driver (100 points)
You must have the README.txt file with your submission stating on the first line which option you are using: 1, 2, or 3, and if 3 then include information where the FSA table is and which function is the driver. If this information is missing, the project will be graded under option 1. If 3 then attach graph.* - picture of the graph.
Implement a token as a triplet {tokenID, tokenInstance, line#} (if using option with line numbers)
Dont forget EOFtk token
Implement the scanner in a separate file with basename "scanner"
For testing purposes, the scanner will be tested using a testing driver implemented in file with basename "testScanner". You need to implement your own tester and include as a part of the project. The tester will ask one token at a time and display the token to the screen one per line, including information (descriptive) on what token class, what token instance, and what line, if applicable.
Invocation:
    scanner [file]
to read from stdin or file file.sp19
Arguments are the same as P0
Wrong invocations may not be graded
Dont confuse executable name with file name with function name
Graded 20 points for style regardless of implementation method
You must have (C++ can be accordingly different)
types including token type in token.h
implement scanner in scanner.c and scanner.h
implement the tester in another file testScanner.c and testScanner.h
main.c processing the arguments (as P0) then calling testScanner() function with interface and preparation as needed.

##########################################################################

P1 Testing
This section is non-exhaustive testing of P1

Create test files:
P1_test1.sp19 containing just one character (with standard \n at the end) :
x
P1_test2.sp19 containing a list of all the tokens listed, all separated by a space or new line. For ids, use x, xy, and xyz, for numbers, use 1, 12, and 23.
x xy xyz 1 12 23
//etc
If WS not required, create another file where some token from above are combined w/o WS (as long as the token combination doesnt create a new token)
P1_test3.sp19 containing a mix of tokens without spaces and with spaces.
x  x+ xy x>xyz
/etc
Test also with some extra comments, should not change the outputs
Run the invocations and check against predictions
$ scanner P1_test
Program error file not found
$ scanner < P1_test1
System error file not found
$ scanner < P1_test1.sp19
IDTk x 1
EOFTk
$ scanner P1_test1
As above
$ scanner P1_test2
Should output all listed tokens, one per line, ending with EOFTk
$ scanner P1_test3
Should output the tokens you have in the file, splitting properly merged tokens
